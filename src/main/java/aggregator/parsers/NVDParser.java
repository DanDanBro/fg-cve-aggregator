/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package aggregator.parsers;

import aggregator.connections.JavaHttpClient;
import aggregator.db.NitriteController;
import aggregator.mappers.VersionRanger;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.reflect.TypeToken;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import utils.Severity;
import utils.Vulnerability;

import java.lang.reflect.Type;
import java.sql.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

import static java.lang.Math.max;
import static java.lang.Thread.sleep;

// This product uses data from the NVD API but is not endorsed or certified by the NVD.

// Modification or False Representation of Content
// If you modify the content accessed through the API, you may not attribute the source as the NVD.
public class NVDParser implements VulnerabilityParser {

    private JavaHttpClient client;
    private final VersionRanger versionRanger;
    private static final Logger logger = LoggerFactory.getLogger(NVDParser.class.getName());
    //@TODO change before shipping
    private static final String DATABASE_URL = "jdbc:sqlite:../purl2cpe/utilities/purl2cpe.db";

    private static final HikariDataSource dataSource;

    static {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(DATABASE_URL);
        config.setMaximumPoolSize(Runtime.getRuntime().availableProcessors());
        dataSource = new HikariDataSource(config);
    }

    private ConcurrentHashMap<String, String> purl2cpeCache;
    //        String[] cpeRemoveCharacters = {"*", "-"};

    private String mnt;
    private final String baseApiUrl = "https://services.nvd.nist.gov/rest/json/cves/2.0";
    //https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate=2021-08-04T13:00:00.000%2B01:00&lastModEndDate=2021-10-22T13:36:00.000%2B01:00

    private static final Map<String, String> supportedForges =
            Map.of("mvn", "pkg:maven", "PyPI", "pkg:pypi", "debian", "pkg:deb/debian");
//                    ,"github", "pkg:github", "bitbucket", "pkg:bitbucket", "gitlab", "pkg:gitlab"); //If github

    public NVDParser(JavaHttpClient client, VersionRanger versionRanger, String mnt) {
        this.client = client;
        this.versionRanger = versionRanger;
        this.mnt = mnt;
        this.purl2cpeCache = new ConcurrentHashMap<>();
    }

    public VersionRanger getVersionRanger() {
        return versionRanger;
    }

    /*
    Took 20 minutes for 236000 entries of NVD
     */
    @Override
    public void getVulnerabilities(NitriteController nitriteController, boolean updatesOnly) {
        try {
            retrieveNVDData(nitriteController, updatesOnly);
//            logger.info("Parsed " + vulnerabilities.size() + " vulnerabilities from NVD");
//            return vulnerabilities;
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    /*
    Added artificial delay to 6 secs between get requests according to https://nvd.nist.gov/developers/start-here
    @TODO delay can probably be lowered
     */
    public HashMap<String, Vulnerability> retrieveNVDData(NitriteController nitriteController, boolean updatesOnly) throws InterruptedException {
        ConcurrentHashMap<String, Vulnerability> vulnerabilities = new ConcurrentHashMap<>();
        int totalResults = 1;
        int startingIndex = 0;

        while (startingIndex < totalResults) {
            long startTime = System.currentTimeMillis();

            String reponse = client.sendGet(baseApiUrl + "/?startIndex=" + startingIndex);
            Gson gson = new Gson();
            JsonObject responseJsonObject = gson.fromJson(reponse, (Type) JsonObject.class);
            totalResults = responseJsonObject.get("totalResults").getAsInt();
            startingIndex += responseJsonObject.get("resultsPerPage").getAsInt();
            logger.info("Total amount of received cve entries: " + startingIndex);

            Type listType = new TypeToken<List<JsonElement>>() {
            }.getType();
            List<JsonElement> myList = gson.fromJson(responseJsonObject.get("vulnerabilities").getAsJsonArray(), listType);

            myList.parallelStream().forEach((arrayEntry) -> {
                try {
                    JsonObject cveJson = arrayEntry.getAsJsonObject().get("cve").getAsJsonObject();
                    Vulnerability vuln = parseNVDcve(cveJson);
                    if (vuln != null) {
                        Optional<Vulnerability> dbVuln = nitriteController.findVulnerabilityEntry(vuln.getId());
                        if (dbVuln.isPresent()) {
                            vuln.merge(dbVuln.get());
                        }
                        else {
                            nitriteController.insertVulnerability(vuln);
                        }
//                        vulnerabilities.put(vuln.getId(), vuln);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            });

            sleep(max(0, 6000 - (System.currentTimeMillis() - startTime)));
        }
        return new HashMap<>(vulnerabilities);
    }

    public @Nullable Vulnerability parseNVDcve(@NotNull JsonObject cve) {
        Vulnerability v = new Vulnerability();
        v.setId(getStringOrNull(cve, "id"));

        if (cve.has("configurations")) {
            //Adds the non-hardware cpes and only continue if any cpe was added
            if (addVulnerableVersions(v, cve.getAsJsonArray("configurations"))) {
                v.setPublishedDate(getStringOrNull(cve, "published"));
                v.setLastModifiedDate(getStringOrNull(cve, "lastModified"));

                for (JsonElement desc : cve.getAsJsonArray("descriptions")) {
                    if ("en".equals(getStringOrNull(desc.getAsJsonObject(), "lang"))) {
                        v.setDescription(getStringOrNull(desc.getAsJsonObject(), "value"));
                        break;
                    }
                }

                if (cve.has("metrics")) {
                    setMetrics(v, cve.getAsJsonObject("metrics"));
                }
                if (cve.has("weaknesses")) {
                    addCwes(v, cve.getAsJsonArray("weaknesses"));
                }
                if (cve.has("references")) {
                    addReferences(v, cve.getAsJsonArray("references"));
                }
            } else {
                return null;
            }
            v.addDataSource("https://nvd.nist.gov/vuln/detail/" + v.getId());
            return v;
        }
        else{
            return null;
        }
    }

    private void setMetrics(Vulnerability v, @NotNull JsonObject metrics) {
        if (metrics.has("cvssMetricV2")) {
            JsonObject metricV2 = metrics.getAsJsonArray("cvssMetricV2").get(0).getAsJsonObject();
            try {
                v.setSeverityV2(Severity.translate(Objects.requireNonNull(getStringOrNull(metricV2, "baseSeverity"))));
            } catch (NullPointerException e) {
                e.printStackTrace();
            }
            if (metricV2.has("cvssData")) {
                JsonObject cvssDataV3 = metricV2.getAsJsonObject("cvssData");
                v.setVectorCVSS2(getStringOrNull(cvssDataV3, "vectorString"));
                v.setScoreCVSS2(getDoubleOrNull(cvssDataV3, "baseScore"));
            }
        }
        if (metrics.has("cvssMetricV30")) {
            setMetricV3(v, metrics.getAsJsonArray("cvssMetricV30").get(0).getAsJsonObject());
        }
        if (metrics.has("cvssMetricV31")) {
            setMetricV3(v, metrics.getAsJsonArray("cvssMetricV31").get(0).getAsJsonObject());
        }
    }

    private void setMetricV3(Vulnerability v, @NotNull JsonObject metricV3) {
        if (metricV3.has("cvssData")) {
            JsonObject cvssDataV3 = metricV3.getAsJsonObject("cvssData");
            v.setVectorCVSS3(getStringOrNull(cvssDataV3, "vectorString"));
            v.setScoreCVSS3(getDoubleOrNull(cvssDataV3, "baseScore"));
            try {
                v.setSeverityV3(Severity.translate(getStringOrNull(metricV3, "baseSeverity")));
            } catch (NullPointerException npe) {
                npe.printStackTrace();
            }
        }
    }

    private void addCwes(Vulnerability v, @NotNull JsonArray weaknesses) {
        for (JsonElement weakness : weaknesses) {
            if (weakness.getAsJsonObject().has("description")) {
                for (JsonElement cweDesc : weakness.getAsJsonObject().get("description").getAsJsonArray()) {
                    if ("en".equals(cweDesc.getAsJsonObject().get("lang").getAsString())) {
                        v.addCweId(getStringOrNull(cweDesc.getAsJsonObject(), "value"));
                        break;
                    }
                }
            }
        }
    }

    /*
    This is a very ugly way to do this
     */
    private boolean addVulnerableVersions(Vulnerability v, @NotNull JsonArray configurations) {
        boolean softwareCpe = false;
        try (Connection connection = dataSource.getConnection()) {
            for (JsonElement conf : configurations) {
                if (conf.getAsJsonObject().has("nodes")) {
                    for (JsonElement nodes : conf.getAsJsonObject().get("nodes").getAsJsonArray()) {
                        JsonObject node = nodes.getAsJsonObject(); // For possible access to operator
                        if (node.has("cpeMatch")) {
                            for (JsonElement cpeMatch : node.getAsJsonArray("cpeMatch")) {
                                JsonObject cpe = cpeMatch.getAsJsonObject();
                                if (cpe.get("vulnerable").getAsBoolean()) {
                                    try {
                                        String[] cpeCriteria = Objects.requireNonNull(getStringOrNull(cpe, "criteria")).split(":");
                                        //Check if cpe is hardware
                                        if (!cpeCriteria[2].equals("h")) {
                                            softwareCpe = true;
                                            String baseCpePurl = executeDistinctPurlQuery(connection, v, String.join(":", Arrays.copyOfRange(cpeCriteria, 0, Math.min(cpeCriteria.length, 5))));
                                            if (!baseCpePurl.equals("NULL")) {
                                                if (!cpeCriteria[5].equals("*") && !cpeCriteria[5].equals("-")) {
                                                    StringBuilder version = new StringBuilder(cpeCriteria[5]);
                                                    for (int i = 6; i < cpeCriteria.length; i++) {
                                                        if (!cpeCriteria[i].equals("*") && !cpeCriteria[i].equals("-")) {
                                                            version.append(".").append(cpeCriteria[i]);
                                                        } else {
                                                            //If we hit an - or * we should be able immediatly ignore the rest
                                                            break;
                                                        }
                                                    }
                                                    v.addPkgVulnerablePurl(baseCpePurl + "@" + version);
                                                }
                                                var versionPkg = versionRanger.getVersions(baseCpePurl);
                                                if (versionPkg != null) {
                                                    var vulnerableVersions = versionRanger.getVulnerableVersionsNVD(getStringOrNull(cpe, "versionStartIncluding"),
                                                            getStringOrNull(cpe, "versionStartExcluding"),
                                                            getStringOrNull(cpe, "versionEndIncluding"),
                                                            getStringOrNull(cpe, "versionEndExcluding"), versionPkg);
                                                    vulnerableVersions.forEach(x -> v.addPkgVulnerablePurl(baseCpePurl + "@" + x));
                                                }
                                            }
                                            //@TODO if purl not in db
//                                        else {
//                                            cpeCriteria = Arrays.stream(cpeCriteria)
//                                                    .filter(entry -> !Arrays.asList(cpeRemoveCharacters).contains(entry))
//                                                    .toArray(String[]::new);
//                                            String baseCpe = String.join(":", cpeCriteria) + ":";
//                                            v.addPkgVulnerablePurl(baseCpe);
//                                        }
                                        }
                                    } catch (NullPointerException npe) {
                                        npe.printStackTrace();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return softwareCpe;
    }

    private String executeDistinctPurlQuery(@NotNull Connection connection, Vulnerability v, @NotNull String cpeId) {
        if (purl2cpeCache.containsKey(cpeId)) {
            return purl2cpeCache.get(cpeId);
        } else {
            //Need to NULL sentinel as concurrentHashMap does not allow null values
            String purlValue = "NULL";
            try {
                PreparedStatement statement = connection.prepareStatement("SELECT DISTINCT purl FROM purl2cpe WHERE cpe LIKE ?");
                statement.setString(1, "%" + cpeId + "%");

                try (ResultSet resultSet = statement.executeQuery()) {
                    while (resultSet.next()) {
                        purlValue = resultSet.getString("purl");
                        if (purlValue.matches("pkg:maven/.*")) {
                            break;
                        }
                        //@TODO for now only maven is supported
//                    if (supportedForges.values()
//                            .stream()
//                            .anyMatch(forge -> finalPurlValue.matches(forge + "/.*"))) {
//                        return finalPurlValue;
//                    }
                    }
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
            purl2cpeCache.put(cpeId, purlValue);
            return purlValue;
        }
    }

    private void addReferences(Vulnerability v, @NotNull JsonArray references) {
        for (JsonElement reference : references) {
            JsonObject ref = reference.getAsJsonObject();
            if (ref.has("url")) {
                String refUrl = ref.get("url").getAsString();
                v.addReference(refUrl);

                if (ref.has("tags")) {
                    for (JsonElement tag : ref.getAsJsonArray("tags")) {
                        if ("Patch".equals(tag.getAsString())) {
//                            addNVDPatchLink(v, refUrl); @TODO change this back after evaluation
                            v.removeReference(refUrl);
                        }
                        if ("Exploit".equals(tag.getAsString())) {
                            v.addExploit(refUrl);
                        }
                    }
                }

            }
        }
    }

    /*
    Method for determining if the "Patch" reference can be put into the patchLinks collection.
    @TODO what kind of urls should be accepted here. Maybe port over PatchFinder.findPatchLinks()
    @TODO does this potentially lead to duplicate actions with the findPathLinks of the references list
     */
    private static void addNVDPatchLink(Vulnerability v, @NotNull String ref) {
//        if (ref.contains("git")) {
//            v.addPatchLink(ref);
//        }
        v.addPatchLink(ref);
    }

    private static @Nullable String getStringOrNull(@NotNull JsonObject jsonObject, String key) {
        return jsonObject.has(key) ? jsonObject.get(key).getAsString() : null;
    }

    private static @Nullable Double getDoubleOrNull(@NotNull JsonObject jsonObject, String key) {
        return jsonObject.has(key) ? jsonObject.get(key).getAsDouble() : null;
    }
}
