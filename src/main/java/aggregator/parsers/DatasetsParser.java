package aggregator.parsers;

import aggregator.connections.GitHelper;
import aggregator.connections.JavaHttpClient;
import aggregator.db.NitriteController;
import aggregator.mappers.VersionRanger;
import aggregator.mappers.YAMLHandler;
import com.opencsv.CSVReader;
import org.apache.commons.io.FileUtils;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.LoaderOptions;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.constructor.Constructor;
import org.yaml.snakeyaml.error.YAMLException;
import org.yaml.snakeyaml.nodes.Tag;
import org.yaml.snakeyaml.representer.Representer;
import utils.Severity;
import utils.Vulnerability;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.regex.Pattern;

public class DatasetsParser implements VulnerabilityParser{

//    private final ConcurrentHashMap<String, Vulnerability> vulnerabilities;
    private final JavaHttpClient client;
    private final VersionRanger versionRanger;
    private GitHelper gitHelper;
    private final String mnt;
    private final Logger logger = LoggerFactory.getLogger(DatasetsParser.class.getName());
    private final int noParseWorkers = 6;
    private NitriteController nitriteController;


    /**
     * The same client is injected in both ExtraParser and the VersionRanger.
     * This will help with Mocking when testing later.
     *
     * @param client - JavaHttpClient
     */
    public DatasetsParser(JavaHttpClient client, VersionRanger versionRanger, String mnt) {
//        this.vulnerabilities = new ConcurrentHashMap<>();
        this.versionRanger = versionRanger;
        this.client = client;
        this.mnt = mnt;
        this.gitHelper = new GitHelper();
    }

    @Override
    public void getVulnerabilities(NitriteController nitriteController, boolean updatesOnly) {
//        if(updatesOnly) return getUpdates();
        this.nitriteController = nitriteController;
        var executor = Executors.newFixedThreadPool(noParseWorkers);
        List<Callable<Object>> parsingTasks = new ArrayList<>();
        parsingTasks.add(() -> {
            logger.info("Parsing database from Safety-DB");
            injectFromSafetyDB();
            return null;
        });
        parsingTasks.add(() -> {
            logger.info("Injecting extra commits from MSR2019 - SAP Dataset");
            injectMSR2019SAP();
            return null;
        });
        parsingTasks.add(() -> {
            logger.info("Injecting statements from project-kb - SAP Research");
            injectSAPProjectKb(mnt + "/datasets");
            return null;
        });
        parsingTasks.add(() -> {
            logger.info("Injecting extra commits from MSR2020 - CPP Dataset");
            injectMSR2020CPP(mnt + "/datasets/all_c_cpp_release2.0.csv");
            return null;
        });
        parsingTasks.add(() -> {
            logger.info("Parsing database from cvedb");
            injectYAMLSource("https://github.com/edoardolanzini/cvedb.git");
            return null;
        });
        parsingTasks.add(() -> {
            logger.info("Parsing database from victims-cve-db");
            injectYAMLSource("https://github.com/victims/victims-cve-db.git");
            return null;
        });
        try {
            executor.invokeAll(parsingTasks);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // Wait for the vulnerability parsers to finish their task.
        executor.shutdown();
//        logger.info("Parsed " + vulnerabilities.size() + " vulnerabilities from Extra Sources");
//        return new HashMap<>(vulnerabilities);
    }

//    public ConcurrentHashMap<String, Vulnerability> getVulnMap() {
//        return this.vulnerabilities;
//    }

    public VersionRanger getVersionRanger() {
        return versionRanger;
    }

//    public HashMap<String, Vulnerability> getVulnerabilitiesInMemory() {
//        return new HashMap<>(vulnerabilities);
//    }

    public void setGitHelper(GitHelper gitHelper) {
        this.gitHelper = gitHelper;
    }

    /**
     * Parses all the additional files in the resources/datasets folder.
     * https://github.com/SAP/project-kb/blob/master/MSR2019/dataset/vulas_db_msr2019_release.csv
     */
    public void injectMSR2019SAP() {
        try {
            String dataSource = "https://raw.githubusercontent.com/SAP/project-kb/master/MSR2019/dataset/vulas_db_msr2019_release.csv";
            var extraCommitsCsv = client.sendGet(dataSource);
            try {
                var reader = new CSVReader(new StringReader(extraCommitsCsv));
                String[] line;
                while ((line = reader.readNext()) != null) {
                    var cveId = line[0];
                    var commitUrl = line[1] + "/commit/" + line[2];
                    var v = new Vulnerability(cveId);
                    v.addPatchLink(commitUrl);
                    v.addDataSource(dataSource);
                    insertVulnerability(v);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * This method injects into the vulnerabilities of the ExtraParser.
     * Taking information from the MSR2020 dataset collection.
     * @param datasetPath - String of the path to look where to download/read data
     * "./src/main/resources/datasets/all_c_cpp_release2.0.csv"
     * @TODO investigate more elegant solution/ use of the cleaned dataset
     */
    public void injectMSR2020CPP(String datasetPath) {
        var datasetFile = new File(datasetPath);
        String dataSource = "https://raw.githubusercontent.com/ZeoVan/MSR_20_Code_vulnerability_CSV_Dataset/master/all_c_cpp_release2.0.csv";
        String data = null;
        if (datasetFile.exists()) {
            try {
                data = FileUtils.readFileToString(datasetFile, StandardCharsets.UTF_8);
                logger.info("Found MSR2020 CPP dataset from memory");
            } catch (IOException e) {
                logger.error("Error while loading MSR2020 CPP file from memory");
                e.printStackTrace();
            }
        } else {
            // Download raw content
            try {
                logger.info("Downloading raw CSV file from MSR2020");
                data = client.sendGet(dataSource);
                try (PrintWriter out = new PrintWriter(datasetPath)) {
                    if (data != null) {
                        logger.info("Writing dataset to memory");
                        out.write(data);
                    }
                } catch (FileNotFoundException e) {
                    logger.error("Error while writing the dataset to memory");
                    e.printStackTrace();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        int counter = 0;

        // Parse the data
        var splits = data.split("\n\\d{1,4},");
        for (String s : splits) {
            var v = parseMSR2020Blob(s);
            if (v != null) {
                v.addDataSource(dataSource);
                insertVulnerability(v);
                if (v.getPatchLinks().size() > 0)   counter += 1;
            }
        }
        logger.info("Found a total of " + counter + " vulnerability in the CPP dataset from MSR2020");
    }

    /**
     * Parses the blob of information from the dataset.
     * @param s - String containing the information to be parsed.
     * @return - Vulnerability Object, null if no patch link is found
     */
    public Vulnerability parseMSR2020Blob(String s) {
        // Extract the information of each of the splits
        var halves = s.split("\"\\{\"\"sha\"\":");
        var firstPart = halves[0].split(",");
        if (firstPart[2].startsWith("CVE")) {
            var cveId = firstPart[2];
            var cweId = firstPart[4];
            var severity = firstPart[5];
            var date = firstPart[8];
            var stringBlob = String.join(",", Arrays.copyOfRange(firstPart, 9, firstPart.length - 1));
            stringBlob = stringBlob.substring(0, Math.min(1000, stringBlob.length()));
            var matcher = Pattern.compile("https://github\\.com/.*/.*/commit/.*,").matcher(stringBlob);
            String patchLink = null;
            while (matcher.find()) {
                patchLink = matcher.group().split(",")[0];
            }
            var v = new Vulnerability(cveId);
            v.setPublishedDate(date);
            v.addPatchLink(patchLink);
            v.addCweId(cweId);
            v.setSeverityV2(Severity.translate(severity));
            return v;
        } else {
            return null;
        }
    }

    /**
     * Injects information in the dictionary from the dataset provided by pyupio on Github.
     * Find more information here: https://github.com/pyupio/safety-db
     * The JSON Feed is updated monthly.
     */
    public void injectFromSafetyDB() {
        try {
            var insecureJson = client.sendGet("https://raw.githubusercontent.com/pyupio/safety-db/master/data/insecure_full.json");

            var jsonObject = new JSONObject(insecureJson.trim());
            Iterator<String> keys = jsonObject.keys();
            var insecureVulns = new HashMap<String, List<JSONObject>>();

            while (keys.hasNext()) {
                var key = keys.next();
                var listVulns = jsonObject.optJSONArray(key);
                if(Objects.nonNull(listVulns)) {
                    insecureVulns.put(key, new ArrayList<>());
                    for (Object listVuln : listVulns) {
                        var vulnObject = (JSONObject) listVuln;
                        insecureVulns.get(key).add(vulnObject);
                    }
                }
            }

            insecureVulns.keySet().parallelStream().forEach((v) -> {insecureVulns.get(v).forEach((l) -> {parseJSONVulnObj(v, l);});});
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void parseJSONVulnObj(String key, JSONObject vulnObject) {
        var cveIds = vulnObject.get("cve");
        if (!cveIds.toString().equals("null")) {
            //If there are multiple CVE-IDs
            if (cveIds.toString().contains(",")) {
                var cves = cveIds.toString().split(",\\s?");
                Arrays.stream(cves).forEach(cve -> insertVulnerability(injectInfoHelper(key, cve, vulnObject)));
            } else {
                // There is only one CVE-ID
                insertVulnerability(injectInfoHelper(key, cveIds.toString(), vulnObject));
            }
        } else {
            // There is only PyUp-id
            var pyupId = (String) vulnObject.get("id");
            insertVulnerability(injectInfoHelper(key, pyupId, vulnObject));
        }
    }

    /**
     * Takes a CVE-ID and a JSONObject from safetydb specification and injects information in the dictionary.
     *
     * @param packageName - name of the package to retrieve vulnerable versions from.
     * @param id          - id of the vulnerability
     * @param vulnObject  - JSON Object containing the information related to the package and its vulnerabilities.
     */
    private Vulnerability injectInfoHelper(String packageName, String id, JSONObject vulnObject) {
        var v = new Vulnerability(id);
        v.setDescription((String) vulnObject.get("advisory"));
        var versionsPgk = versionRanger.getVersions("pkg:pypi/" + packageName);
        if (versionsPgk != null) {
            var specs = vulnObject.getJSONArray("specs");
            var ranges = new ArrayList<String>();
            for(int i = 0; i < specs.length(); i++) {
                ranges.add(specs.getString(i));
            }
            var vulnerableVersions = new ArrayList<String>();
            for(var range : ranges) {
                vulnerableVersions.addAll(versionRanger.getVulnerableVersionsJSON(range, versionsPgk));
            }
            vulnerableVersions.forEach(x -> v.addPkgVulnerablePurl("pkg:pypi/" + packageName + "@" + x));
        }
        v.addDataSource("https://raw.githubusercontent.com/pyupio/safety-db/master/data/insecure_full.json");
        return v;
    }

    /**
     * This method can pull information from https://github.com/fabric8-analytics/cvedb
     * and https://github.com/victims/victims-cve-db
     * The bot that creates PRs is by far the best mapper between NVD and package coordinates.
     * Unfortunately, the repo is not very maintained and that means PRs are not merged so often.
     * Example of inputs:
     * https://github.com/victims/victims-cve-db.git
     * https://github.com/fabric8-analytics/cvedb.git
     */
    public void injectYAMLSource(String repoUrl) {
        var repoName = repoUrl.split("/")[4].split("\\.")[0];
        var cloneDirectoryPath = mnt + "/datasets/" + repoName;
        var checkDirAlreadyExists = new File(cloneDirectoryPath);
        if (!checkDirAlreadyExists.exists()) {
            gitHelper.cloneRepo(repoUrl, cloneDirectoryPath, null);
        }
        parseYAMLInformation(cloneDirectoryPath, repoUrl);
    }

    public void parseYAMLInformation(String cloneDirectoryPath, String dataSource) {
        var years = new File(cloneDirectoryPath + "/database/java").list();
        for (String year : years) {
            parseJavaYamlSource(cloneDirectoryPath, year, dataSource.replace(".git", "/tree/master/database/java/" + year + "/"));
        }

        var yearsPython = new File(cloneDirectoryPath + "/database/python").list();
        for (String year : yearsPython) {
            parsePythonYamlSource(cloneDirectoryPath, year, dataSource.replace(".git", "/tree/master/database/python/" + year + "/"));
        }
    }

    public void parseJavaYamlSource(String cloneDirectoryPath, String year, String dataSource) {
        Representer customRepresenter = new Representer(new DumperOptions());
        customRepresenter.addClassTag(YAMLHandler.JavaVulnMapper.class, Tag.MAP);
        Yaml javaYaml = new Yaml(new Constructor(YAMLHandler.JavaVulnMapper.class, new LoaderOptions()),
                customRepresenter);

        try {
            var pathToYearDir = cloneDirectoryPath + "/database/java/" + year;
            var files = listFilesUsingDirectoryStream(pathToYearDir);
            for (String file : files) {
//                logger.info("Parsing java statement file " + file + " from year " + year);
                var content = Files.readString(Paths.get(pathToYearDir + "/" + file));
                YAMLHandler.JavaVulnMapper javaPgk = javaYaml.load(content);

                var vulnerablePURL = new ArrayList<String>();
                for (YAMLHandler.JavaPgkMapper affectedJavaPkg : javaPgk.affected) {
                    // Check if you already have versions from the VersionRanger
                    var versionsPgk = versionRanger.getVersions("pkg:maven/" +
                        affectedJavaPkg.groupId + "/" +
                        affectedJavaPkg.artifactId);
                    // Find vulnerable versions and create purls in the mappings
                    var vulnerableVersions = versionRanger.getVulnerableVersionsYAML(affectedJavaPkg.version, versionsPgk);
                    vulnerablePURL.addAll(versionRanger.buildPURLSMaven(affectedJavaPkg, vulnerableVersions));
                }
                var v = YAMLHandler.buildJavaVulnerabilityFromYaml(javaPgk, vulnerablePURL);
                v.addDataSource(dataSource + file);
                insertVulnerability(v);
            }
        } catch (IOException e) {
            System.out.println("Could not list any files for year: " + year);
        }
    }

    /**
     * Parses Python YAML statements.
     * @param cloneDirectoryPath - path to statements
     * @param year - folder name
     */
    public void parsePythonYamlSource(String cloneDirectoryPath, String year, String dataSource) {
        Representer customRepresenter = new Representer(new DumperOptions());
        customRepresenter.addClassTag(YAMLHandler.PythonVulnMapper.class, Tag.MAP);
        Yaml pythonYaml = new Yaml(new Constructor(YAMLHandler.PythonVulnMapper.class, new LoaderOptions()),
                customRepresenter);
        try {
            var pathToYearDir = cloneDirectoryPath + "/database/python/" + year;
            var files = listFilesUsingDirectoryStream(pathToYearDir);
            for (String file : files) {
//                logger.info("Parsing python statement file " + file + " from year " + year);
                var content = Files.readString(Paths.get(pathToYearDir + "/" + file));
                YAMLHandler.PythonVulnMapper pythonPgk = pythonYaml.load(content);

                var vulnerablePURL = new ArrayList<String>();
                for (YAMLHandler.PythonPgkMapper affectedPythonPkg : pythonPgk.affected) {
                    // Check if you already have versions from the VersionRanger
                    var versionsPgk = versionRanger.getVersions("pkg:pypi/" + affectedPythonPkg.name);
                    // Find vulnerable versions and create purls in the mappings
                    var vulnerableVersions = versionRanger.getVulnerableVersionsYAML(affectedPythonPkg.version, versionsPgk);
                    vulnerablePURL.addAll(versionRanger.buildPURLSPypi(affectedPythonPkg, vulnerableVersions));
                }
                var v = YAMLHandler.buildPythonVulnerabilityFromYaml(pythonPgk, vulnerablePURL);
                v.addDataSource(dataSource + file);
                insertVulnerability(v);
            }
        } catch (IOException e) {
            System.out.println("Could not list any files for year: " + year);
        }
    }

    /**
     * Injects the information contained in the project-kb repo on GH.
     */
    public void injectSAPProjectKb(String cloneDir) {
        // Step 1: Clone the repo
        var repoUrl = "https://github.com/SAP/project-kb.git";
        var cloneDirectoryPath = cloneDir + "/project-kb";
        var checkDirAlreadyExists = new File(cloneDirectoryPath);
        if (!checkDirAlreadyExists.exists()) {
            cloneDirectoryPath = gitHelper.cloneRepo(repoUrl,
                    cloneDirectoryPath,
                    "origin/vulnerability-data");
        }
        try {
            var directories = new File(cloneDirectoryPath + "/statements").listFiles(File::isDirectory);
            Representer customRepresenter = new Representer(new DumperOptions());
            customRepresenter.addClassTag(YAMLHandler.SAPVulnMapper.class, Tag.MAP);
            Yaml yaml = new Yaml(new Constructor(YAMLHandler.SAPVulnMapper.class, new LoaderOptions()),
                    customRepresenter);
            for (File cveDir : directories) {
//                logger.info("Parsing statement file for " + cveDir.getName());
                var content = Files.readString(Paths.get(cveDir.getPath() + "/statement.yaml"));
                try {
                    var v = ((YAMLHandler.SAPVulnMapper) yaml.load(content)).translateFromStatement();
                    if (v.getPkgVulnerablePurls().size() > 0) versionRanger.sortVulnerabilityPurls(v);
                    v.addDataSource(repoUrl.replace(".git", "/tree/vulnerability-data/statements/" + cveDir + "/statement.yaml"));
                    insertVulnerability(v);
                } catch (YAMLException e) {
                    logger.error("Could not import statement " + cveDir.getName());
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Helper function to get all the files in a directory.
     *
     * @param dir path to the directory to list files
     * @return Set of Strings where each string is a file name of a YAML file with a vulnerability
     * @throws IOException
     */
    public Set<String> listFilesUsingDirectoryStream(String dir) throws IOException {
        var fileList = new HashSet<String>();
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(dir))) {
            for (Path path : stream) {
                if (!Files.isDirectory(path)) {
                    if (!path.getFileName().toString().equals(".gitkeep")) {
                        fileList.add(path.getFileName()
                                .toString());
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return fileList;
    }

    /**
     * Looks for a vulnerability that was already in the map.
     * If found, it updates it, else puts a new entry.
     *
     * @param v - Vulnerability to insert in the map.
     */
    private void insertVulnerability(Vulnerability v) {
//        logger.info("Parsed Vulnerability with ID - " + v.getId());
//        if (vulnerabilities.get(v.getId()) == null) {
//            vulnerabilities.put(v.getId(), v);
//        } else {
//            Vulnerability existing = vulnerabilities.get(v.getId());
//            existing.merge(v);
//            vulnerabilities.put(v.getId(), existing);
//        }

        Optional<Vulnerability> dbVuln = nitriteController.findVulnerabilityEntry(v.getId());
        if (dbVuln.isPresent()) {
            v.merge(dbVuln.get());
        }
        else {
            nitriteController.insertVulnerability(v);
        }
    }
}
