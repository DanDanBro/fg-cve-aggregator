/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package aggregator.parsers;

import aggregator.connections.GitHelper;
import aggregator.mappers.YAMLHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.LoaderOptions;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.constructor.Constructor;
import org.yaml.snakeyaml.error.YAMLException;
import org.yaml.snakeyaml.nodes.Tag;
import org.yaml.snakeyaml.representer.Representer;
import utils.Vulnerability;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;

public class OSSFuzzParser implements VulnerabilityParser {

    private GitHelper gitHelper;
    private final String mnt;
    private static final Logger logger = LoggerFactory.getLogger(OSSFuzzParser.class.getName());

    /**
     * Parser for oss-fuzz-vulns.
     * @param mnt - path to mnt
     */
    public OSSFuzzParser(String mnt) {
        this.mnt = mnt;
        this.gitHelper = new GitHelper();
    }

    public void setGitHelper(GitHelper gitHelper) {
        this.gitHelper = gitHelper;
    }

    @Override
    public HashMap<String, Vulnerability> getVulnerabilities(boolean updatesOnly) {
        // Clone the repo to mnt
        var vulnerabilities = new HashMap<String, Vulnerability>();
        var cloneDirectoryPath = mnt + "/datasets/oss-fuzz-vulns/";
        String repoUrl = "https://github.com/google/oss-fuzz-vulns.git";
        gitHelper.cloneRepo(repoUrl,
                cloneDirectoryPath,
                null);
        //  Parse statements with YAML
        var directories = new File(cloneDirectoryPath + "vulns/").listFiles(File::isDirectory);
        Representer customRepresenter = new Representer(new DumperOptions());
        customRepresenter.addClassTag(YAMLHandler.OSSFuzzMapper.class, Tag.MAP);
        Yaml yaml = new Yaml(new Constructor(YAMLHandler.OSSFuzzMapper.class, new LoaderOptions()),
                customRepresenter);
        var counter = 0;
        String content = "";
        for (File directory : directories) {
            var vulnStatements = directory.listFiles((d, name) -> name.endsWith(".yaml"));
            for (File statement : vulnStatements) {
                try {
                    content = Files.readString(Paths.get(statement.getPath()));
                    content = content.replaceAll("package:", "packageInfo:");
                    var vulnOSSFuzz = (YAMLHandler.OSSFuzzMapper) yaml.load(content);
                    if (vulnOSSFuzz.getWithdrawn() != null) {
                        var vuln = translateFromOSSFuzz(vulnOSSFuzz);
                        vulnerabilities.put(vuln.getId(), vuln); //@TODO Might need to change depending on the storage option used
                    }
                    else {
                        //@TODO remove entry from storage
                        System.out.println("Remove this entry from overall storage");
                    }
                    counter += 1;
                } catch (IOException | YAMLException e) {
                    logger.error("Could not parse " + statement.getPath());
                    e.printStackTrace();
                }
            }
        }

        logger.info("Parsed " + counter + " vulnerabilities from oss-fuzz-vulns");
        return vulnerabilities;
    }

    /**
     * Helper to translate between OSSFuzz statements and Vulnerability Objects
     * @param vulnOSSFuzz - OSSFuzz statement object
     * @return vulnerability object
     */
    private Vulnerability translateFromOSSFuzz(YAMLHandler.OSSFuzzMapper vulnOSSFuzz) {
        var v = new Vulnerability();
        v.setId(vulnOSSFuzz.id);
        v.setPublishedDate(vulnOSSFuzz.published.split("T")[0]);
        v.setLastModifiedDate(vulnOSSFuzz.modified.split("T")[0]);
        v.setDescription(vulnOSSFuzz.summary + "\n" + vulnOSSFuzz.details);
        if (vulnOSSFuzz.getAffected() != null && vulnOSSFuzz.getAffected().get(0) != null) {
            if (vulnOSSFuzz.getAffected().get(0).getPackageInfo() != null) { //This is tied into the need for a baseCpe
                v.setBaseCpe(getBasePurl(vulnOSSFuzz.getAffected().get(0).getPackageInfo()));
            }
            if (vulnOSSFuzz.getAffected().get(0).getEcosystem_specific() != null) {
                v.setSeverityV3(vulnOSSFuzz.getAffected().get(0).getEcosystem_specific().getSeverity());
            }
        }

        for (YAMLHandler.OSSFuzzAffected affectedPkg : vulnOSSFuzz.getAffected()) {
            String basePurl = getBasePurl(affectedPkg.getPackageInfo());
            if (affectedPkg.getRanges() != null) {
                for (YAMLHandler.OSSFuzzRange range : affectedPkg.getRanges()) {
                    if (range.getType().equals("GIT")) {
                        for (Map<String, String> events : range.getEvents()) {
                            if (events.get("fixed") != null) {
                                v.addPatchLink(getCommitUrl(range.getRepo(), events.get("fixed")));
                            }
                            if (events.get("introduced") != null) {
                                v.addIntroducedVulnerableLink(getCommitUrl(range.getRepo(), events.get("introduced")));
                            }
                        }
                    }
                }
            }
            if (affectedPkg.getVersions() != null) {
                for (String version : affectedPkg.getVersions()) {
                    v.addPkgVulnerablePurl(basePurl + "@" + version);
                }
            }

        }
        vulnOSSFuzz.references.forEach(ref -> v.addReference(ref.url));

        return v;
    }

    private String getBasePurl(YAMLHandler.OSSFuzzPackageInfo ossFuzzPackageInfo) {
        if (ossFuzzPackageInfo.getEcosystem().equals("OSS-Fuzz")) {
            return "pkg:deb/debian/" + ossFuzzPackageInfo.name;
        }
        if (ossFuzzPackageInfo.getEcosystem().equals("PyPI")) {
            return "pkg:pypi/" + ossFuzzPackageInfo.name;
        }
        logger.info("Deviant ecosystem: " + ossFuzzPackageInfo.getEcosystem());
        return ossFuzzPackageInfo.getPurl();
    }

    private String getCommitUrl(String baseRepo, String commitHash) {
        if (baseRepo.startsWith("git://")) {
            var repo = "https://" + baseRepo.substring(6).split("/")[0];
            var project = baseRepo.substring(6).split("/")[1];

            return repo + "?p=" + project + ";a=commit;h=" + commitHash;
        } else if (baseRepo.startsWith("https://github") | baseRepo.startsWith("https://gitlab")) {
            var repo = baseRepo.endsWith(".git") ? baseRepo.substring(0, baseRepo.length() - 4) : baseRepo;

            return repo + "/commit/" + commitHash;
        } else {
            if (baseRepo.contains("git.qemu.org")) {
                return baseRepo.replace("git.qemu.org/git/qemu.git", "github.com/qemu/qemu") + "/commit/" + commitHash;
            }
            if (baseRepo.contains("git.savannah.gnu.org")) {
                return baseRepo.replace("/git/", "/cgit/") + "/commit/?id=" + commitHash;
            }
            return baseRepo + "/commit/?id=" + commitHash;
        }
    }
}
