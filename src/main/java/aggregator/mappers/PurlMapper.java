/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package aggregator.mappers;

import aggregator.connections.JavaHttpClient;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import utils.PatchFinder;
import utils.Vulnerability;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.DateTimeException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;

public class PurlMapper {
    VersionRanger versionRanger;
    PatchFinder patchFinder;
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
    public HashMap<String, String> mavenMap;     // repo_url -> purl
    public HashMap<String, String> pypiMap;      // repo_url -> purl
    public HashMap<String, String> cpeMap;       // cpe_base -> repo_url
    public HashMap<String, String> debianCpeMap; // cpe_base -> purl

    public Pool cpe2purl;     // cpe_base -> purl
    public Pool repo2purl;    // repo_url -> purl
    public int INITIAL_WEIGHT_REPO = 10;
    public int INITIAL_WEIGHT_CPE  = 10;
    public String strategy;

    private static final Logger logger = LoggerFactory.getLogger(PurlMapper.class.getName());

    public PurlMapper(VersionRanger versionRanger,
                      String pathToMaps,
                      String inferStrategy,
                      JavaHttpClient client) {
        this.versionRanger = versionRanger;
        this.strategy      = inferStrategy;
        this.mavenMap      = loadReposMapFromMemory(pathToMaps + "repo_map_maven.json");
        this.pypiMap       = loadReposMapFromMemory(pathToMaps + "repo_map_pypi.json");
        this.cpeMap        = loadReposMapFromMemory(pathToMaps + "cpe_map_repos.json");
        this.debianCpeMap  = loadDebianCPEMap(client);

        this.cpe2purl      = createCpe2PurlPool(cpeMap, mavenMap, pypiMap, debianCpeMap);
        this.repo2purl     = createRepo2PurlPool(mavenMap, pypiMap);
    }

    /**
     * Constructor for the repo2purl voting pool.
     * @param mavenMap - maven repo_url -> purl map.
     * @param pypiMap  - pypi  repo_url -> purl map.
     * @return a voting pool that joins the two maps.
     */
    private Pool createRepo2PurlPool(HashMap<String, String> mavenMap,
                                     HashMap<String, String> pypiMap) {
        var maps = Arrays.asList(mavenMap, pypiMap);
        return new Pool(maps, INITIAL_WEIGHT_REPO);
    }

    /**
     * Constructor for the cpe2purl voting pool.
     * @param cpeMap - cpe_base -> repo_url map
     * @param mavenMap - repo_url -> purl map
     * @param pypiMap -  repo_url -> purl map
     * @param debianCpeMap - base_cpe -> purl
     * @return a voting pool with cpe_base -> purl correspondence.
     */
    private Pool createCpe2PurlPool(HashMap<String, String> cpeMap,
                                    HashMap<String, String> mavenMap,
                                    HashMap<String, String> pypiMap,
                                    HashMap<String, String> debianCpeMap) {
        cpeMap.keySet().forEach(cpe -> {
            var repo = cpeMap.get(cpe);
            if (mavenMap.containsKey(repo)) debianCpeMap.put(cpe, mavenMap.get(repo));
            if (pypiMap.containsKey(repo))  debianCpeMap.put(cpe, pypiMap.get(repo));
        });
        var maps = Collections.singletonList(debianCpeMap);
        return new Pool(maps, INITIAL_WEIGHT_CPE);
    }

    /**
     * Loads the CPE list from Debian Security Advisories.
     * Also handles aliases of those CPEs.
     * @return cpe -> purl map.
     */
    public HashMap<String, String> loadDebianCPEMap(JavaHttpClient client) {
        var map = new HashMap<String, String>();
        var listUrl    = "https://salsa.debian.org/security-tracker-team/security-tracker/-/raw/master/data/CPE/list";
        var aliasesUrl = "https://salsa.debian.org/security-tracker-team/security-tracker/-/raw/master/data/CPE/aliases";

        var cpeList = client.sendGet(listUrl);
        Arrays.stream(cpeList.split("\n")).forEach(line -> {
            var info = line.split(";");
            var pkg  = info[0];
            var cpe  = info[1].replace("/", "2.3:");
            var purl = "pkg:deb/debian/" + pkg;
            map.put(cpe, purl);
        });

        var aliasesList = client.sendGet(aliasesUrl);
        var aliases = aliasesList.split("\n");
        for (int i = 0; i < aliases.length; i++) {
            var line = aliases[i];
            if (line.startsWith("cpe")) {
                var cpeGroup = new ArrayList<String>();
                while (line.startsWith("cpe")) {
                    cpeGroup.add(line.replace("/", "2.3:"));
                    i += 1;
                    line = aliases[i];
                }
                cpeGroup.forEach(cpeAlias -> {
                    if (map.containsKey(cpeAlias)) {
                        cpeGroup.forEach(cpe -> map.put(cpe, map.get(cpeAlias)));
                    }
                });
            }
        }

        return map;
    }

    private static HashMap<String, String> loadReposMapFromMemory(String path) {
        var map = new File(path);
        if (map.exists()) {
            try {
                var jsonString = FileUtils.readFileToString(map, StandardCharsets.UTF_8);
                return new Gson().fromJson(jsonString, new TypeToken<HashMap<String, String>>() {}.getType());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return new HashMap<>();
    }

    /**
     * Given a vulnerability, it manipulates it to either store or infer mappings.
     * @param v - Vulnerability object
     */
    public void inferPurls(Vulnerability v, PatchFinder pf) {
        var baseRepo    = pf.getBaseRepo(v);
        var baseCPE     = v.getBaseCpe();
        var patchedDate = getPatchDateVulnerability(v);

        var hasPURLs    = v.getPkgVulnerablePurls().size() > 0;
        var hasCPEs     = baseCPE != null;
        var infoToInfer = baseRepo != null && (hasCPEs || patchedDate != null);

        var repo2purl = strategy.equals("both") || strategy.equals("repo2purl");
        var cpe2purl  = strategy.equals("both") || strategy.equals("cpe2purl");

        if ((infoToInfer || hasPURLs) && repo2purl) {
            repo2PurlInfer(v, patchedDate, baseRepo);
        }
    }

    /**
     * REPO2PURL strategy implementation.
     * @param v - Vulnerability Object to infer/store information about
     * @param patchedDate - date in which the vulnerability was patched
     * @param baseRepo - base repo that was extracted from references
     */
    public void repo2PurlInfer(Vulnerability v,
                               LocalDateTime patchedDate,
                               String baseRepo) {
        if (baseRepo == null) return;

        var basePurl = getPurlBase(v);

        if (basePurl != null) {
            repo2purl.insertVote(baseRepo, basePurl);
        }
        else {
            basePurl = repo2purl.getMostVoted(baseRepo);
            if (basePurl != null) {
                if (patchedDate != null && v.getPkgVulnerablePurls().size() == 0) {
                    var inferredPurls = versionRanger.getPurlsBeforeDate(basePurl, patchedDate);
                    inferredPurls.forEach(v::addPkgVulnerablePurl);
                }
                if (patchedDate != null && v.getFirstPatchedPurls().size() == 0) {
                    var firstPatchedPurl = versionRanger.getFirstPurlAfterDate(basePurl, patchedDate);
                    if (firstPatchedPurl != null) v.addFirstPatchedPurl(firstPatchedPurl);
                }
            }
        }
    }

    /**
     * Finds the patching date for the vulnerability.
     * Either the latest patch date or the published date of the vulnerability.
     * @param v - Vulnerability Object
     * @return DateTime
     */
    public LocalDateTime getPatchDateVulnerability(Vulnerability v) {
        LocalDateTime patchedDate = null;

        if (v.getPatches().size() > 0) {
            var dateWrapper = new Object(){ LocalDateTime value; };
            dateWrapper.value = LocalDateTime.of(1950, 1, 1, 0, 0);
            v.getPatches().forEach(patch->{
                if (patch.getPatchDate() != null) {
                    LocalDateTime date;
                    try {
                        date = LocalDateTime.parse(patch.getPatchDate(), formatter);
                    }
                    catch (DateTimeException dte) {
                        date = LocalDate.parse(patch.getPatchDate(), formatter).atStartOfDay();
                    }
                    if (date.isAfter(dateWrapper.value)) {
                        dateWrapper.value = date;
                    }
                }
            });
            patchedDate = dateWrapper.value;
        } else {
            if (v.getPublishedDate() != null) {
                patchedDate = LocalDateTime.parse(v.getPublishedDate(), formatter);
            }
        }
        return patchedDate;
    }

    /**
     * Retrieves the ecosystem and package name from the purls.
     * @param v - Vulnerability Object storing PURLs.
     * @return String
     */
    public String getPurlBase(Vulnerability v) {
        if (v.getPkgVulnerablePurls().size() == 0) return null;
        var firstPurl = v.getPkgVulnerablePurls().iterator().next();
        return firstPurl.split("@")[0];
    }
}
